<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>F1 24 Admin Panel</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
      :root {
        --primary: #f34646;
        --primary-hover: #f67070;
        --secondary: #3d3dfc;
        --secondary-hover: #5050fd;
        --success: #10b981;
        --danger: #ef4444;
        --warning: #f59e0b;
        --dark: #121212;
        --darker: #0a0a0a;
        --card: #1e1e1e;
        --card-hover: #252525;
        --card-header: #252525;
        --border: #323232;
        --text: #e2e2e2;
        --text-muted: #a0a0a0;
        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.2);
        --shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 2px 4px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        --transition: all 0.2s ease;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        background-color: var(--dark);
        color: var(--text);
        line-height: 1.6;
        min-height: 100vh;
      }

      .layout {
        display: grid;
        grid-template-columns: 240px 1fr;
        min-height: 100vh;
      }

      .sidebar {
        background-color: var(--darker);
        padding: 1.5rem;
        position: fixed;
        width: 240px;
        height: 100vh;
        overflow-y: auto;
        border-right: 1px solid var(--border);
      }

      .sidebar-logo {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 2.5rem;
      }

      .sidebar-logo h1 {
        font-size: 1.25rem;
        font-weight: 700;
        color: white;
        margin-left: 0.5rem;
      }

      .sidebar-logo i {
        color: var(--primary);
        font-size: 1.5rem;
      }

      .nav-section {
        margin-bottom: 1.5rem;
      }

      .nav-section-title {
        text-transform: uppercase;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-muted);
        margin-bottom: 0.75rem;
        padding-left: 0.5rem;
      }

      .nav-list {
        list-style: none;
      }

      .nav-item {
        margin-bottom: 0.25rem;
      }

      .nav-link {
        display: flex;
        align-items: center;
        padding: 0.75rem;
        border-radius: 0.5rem;
        color: var(--text);
        text-decoration: none;
        transition: var(--transition);
      }

      .nav-link:hover {
        background-color: rgba(255, 255, 255, 0.05);
      }

      .nav-link.active {
        background-color: rgba(243, 70, 70, 0.1);
        color: var(--primary);
      }

      .nav-link i {
        margin-right: 0.75rem;
        width: 1.25rem;
        text-align: center;
      }

      .content {
        grid-column: 2;
        padding: 2rem;
        max-width: 1400px;
      }

      .top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
      }

      .page-title {
        font-size: 1.75rem;
        font-weight: 700;
      }

      .user-menu {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .user-info {
        display: flex;
        align-items: center;
        padding: 0.5rem 1rem;
        border-radius: 9999px;
        background-color: var(--card);
        border: 1px solid var(--border);
      }

      .user-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background-color: var(--secondary);
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-weight: 600;
        margin-right: 0.75rem;
      }

      .user-name {
        font-weight: 500;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.625rem 1.25rem;
        font-weight: 500;
        border-radius: 0.5rem;
        border: none;
        cursor: pointer;
        transition: var(--transition);
        background-color: var(--card);
        color: var(--text);
      }

      .btn i {
        margin-right: 0.5rem;
      }
      
      .btn-primary {
        background-color: var(--primary);
        color: white;
      }

      .btn-primary:hover {
        background-color: var(--primary-hover);
      }

      .btn-secondary {
        background-color: var(--secondary);
        color: white;
      }

      .btn-secondary:hover {
        background-color: var(--secondary-hover);
      }

      .btn-danger {
        background-color: var(--danger);
        color: white;
      }

      .btn-danger:hover {
        opacity: 0.9;
      }

      .btn-sm {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
      }

      .btn-icon {
        width: 2.5rem;
        height: 2.5rem;
        padding: 0;
        border-radius: 0.5rem;
      }

      .btn-icon i {
        margin: 0;
      }

      .card {
        background-color: var(--card);
        border-radius: 0.75rem;
        box-shadow: var(--shadow);
        margin-bottom: 1.5rem;
        border: 1px solid var(--border);
        overflow: hidden;
      }

      .card-header {
        padding: 1.25rem;
        background-color: var(--card-header);
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .card-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin: 0;
      }

      .card-body {
        padding: 1.25rem;
      }

      .card-footer {
        padding: 1.25rem;
        border-top: 1px solid var(--border);
        background-color: rgba(0, 0, 0, 0.1);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1.5rem;
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.75rem;
        font-size: 0.875rem;
        font-weight: 500;
        border-radius: 9999px;
      }

      .status-badge i {
        margin-right: 0.375rem;
      }

      .status-badge.active {
        background-color: rgba(16, 185, 129, 0.1);
        color: var(--success);
      }

      .status-badge.warning {
        background-color: rgba(245, 158, 11, 0.1);
        color: var(--warning);
      }

      .status-badge.current {
        background-color: rgba(61, 61, 252, 0.1);
        color: var(--secondary);
        border: 1px solid rgba(61, 61, 252, 0.2);
      }

      .form-group {
        margin-bottom: 1.25rem;
      }

      .form-label {
        display: block;
        margin-bottom: 0.5rem;
        font-weight: 500;
      }

      .form-control {
        width: 100%;
        padding: 0.75rem;
        border-radius: 0.5rem;
        border: 1px solid var(--border);
        background-color: rgba(255, 255, 255, 0.04);
        color: var(--text);
        font-size: 1rem;
        transition: var(--transition);
      }

      .form-control:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 2px rgba(243, 70, 70, 0.2);
      }

      .form-control:disabled {
        background-color: rgba(0, 0, 0, 0.1);
        opacity: 0.7;
        cursor: not-allowed;
      }

      .form-select {
        appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23a0a0a0' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 0.75rem center;
        background-size: 16px 12px;
      }

      .flex {
        display: flex;
      }

      .flex-between {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .flex-center {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .gap-2 {
        gap: 0.5rem;
      }
      
      .gap-4 {
        gap: 1rem;
      }

      .mb-4 {
        margin-bottom: 1rem;
      }

      .mb-6 {
        margin-bottom: 1.5rem;
      }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
      }

      th, td {
        padding: 1rem;
        border-bottom: 1px solid var(--border);
        text-align: left;
      }

      th {
        color: var(--text-muted);
        font-weight: 500;
        letter-spacing: 0.025em;
      }

      tbody tr {
        transition: var(--transition);
      }

      tbody tr:hover {
        background-color: rgba(255, 255, 255, 0.02);
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      .table-responsive {
        overflow-x: auto;
      }

      .pill {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        border-radius: 9999px;
        font-size: 0.875rem;
        font-weight: 500;
      }

      .pill.team-RedBull {
        background-color: rgba(6, 0, 239, 0.15);
        color: #4444ff;
      }

      .pill.team-Mercedes {
        background-color: rgba(0, 210, 190, 0.15);
        color: #00d2be;
      }

      .pill.team-Ferrari {
        background-color: rgba(220, 0, 0, 0.15);
        color: #ff0000;
      }

      .pill.team-McLaren {
        background-color: rgba(255, 152, 0, 0.15);
        color: #ff9800;
      }

      .pill.team-AstonMartin {
        background-color: rgba(0, 111, 98, 0.15);
        color: #006f62;
      }

      .pill.team-Alpine {
        background-color: rgba(0, 144, 255, 0.15);
        color: #0090ff;
      }

      .pill.team-Williams {
        background-color: rgba(0, 90, 255, 0.15);
        color: #005aff;
      }

      .pill.team-AlphaTauri {
        background-color: rgba(44, 44, 44, 0.15);
        color: #8a8a8a;
      }

      .pill.team-AlfaRomeo {
        background-color: rgba(153, 0, 0, 0.15);
        color: #900;
      }

      .pill.team-Haas {
        background-color: rgba(182, 186, 189, 0.15);
        color: #b6babd;
      }

      .status-message {
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        margin-top: 1rem;
        display: flex;
        align-items: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .status-message.visible {
        opacity: 1;
      }

      .status-message i {
        margin-right: 0.75rem;
        font-size: 1.25rem;
      }

      .status-success {
        background-color: rgba(16, 185, 129, 0.1);
        color: var(--success);
        border: 1px solid rgba(16, 185, 129, 0.2);
      }

      .status-error {
        background-color: rgba(239, 68, 68, 0.1);
        color: var(--danger);
        border: 1px solid rgba(239, 68, 68, 0.2);
      }

      .track-card {
        display: flex;
        align-items: center;
        padding: 1rem;
        background-color: rgba(255, 255, 255, 0.02);
        border-radius: 0.5rem;
        border: 1px solid var(--border);
        margin-bottom: 1rem;
      }

      .track-icon {
        width: 48px;
        height: 48px;
        background-color: var(--primary);
        border-radius: 0.5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-right: 1rem;
        color: white;
        font-size: 1.5rem;
      }

      .track-info {
        flex-grow: 1;
      }

      .track-name {
        font-weight: 600;
        font-size: 1.125rem;
      }

      .telemetry-instructions {
        background-color: rgba(255, 255, 255, 0.03);
        border-radius: 0.5rem;
        padding: 1rem;
        margin-top: 1.25rem;
      }

      .telemetry-instructions h4 {
        margin-bottom: 0.75rem;
        font-weight: 600;
      }

      .telemetry-instructions ol {
        padding-left: 1.5rem;
      }

      .telemetry-instructions li {
        margin-bottom: 0.5rem;
      }

      code {
        background-color: rgba(0, 0, 0, 0.2);
        padding: 0.2rem 0.4rem;
        border-radius: 0.25rem;
        font-family: monospace;
        font-size: 0.875rem;
      }

      .info-card {
        display: flex;
        flex-direction: column;
        padding: 1.25rem;
        border-radius: 0.75rem;
        background-color: var(--card);
        border: 1px solid var(--border);
      }

      .info-card-title {
        font-size: 0.875rem;
        color: var(--text-muted);
        margin-bottom: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .info-card-value {
        font-size: 1.5rem;
        font-weight: 700;
        color: white;
      }

      /* Animation effects */
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }

      .animate-in {
        animation: fadeIn 0.3s ease-out forwards;
      }

      /* Responsive adjustments */
      @media (max-width: 1024px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .sidebar {
          display: none;
        }

        .content {
          grid-column: 1;
          padding: 1.5rem;
          width: 100%;
        }
      }

      @media (max-width: 768px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <!-- Sidebar Navigation -->
      <aside class="sidebar">
        <div class="sidebar-logo">
          <i class="bi bi-flag-checkered"></i>
          <h1>F1 Timings</h1>
        </div>
        
        <div class="nav-section">
          <div class="nav-section-title">General</div>
          <ul class="nav-list">
            <li class="nav-item">
              <a href="/admin" class="nav-link active">
                <i class="bi bi-speedometer2"></i>
                Dashboard
              </a>
            </li>
            <li class="nav-item">
              <a href="/admin/users" class="nav-link">
                <i class="bi bi-people"></i>
                Users
              </a>
            </li>
          </ul>
        </div>
        
        <div class="nav-section">
          <div class="nav-section-title">Telemetry</div>
          <ul class="nav-list">
            <li class="nav-item">
              <a href="/display" class="nav-link" target="_blank">
                <i class="bi bi-columns-gap"></i>
                Live Dashboard
                <i class="bi bi-box-arrow-up-right" style="margin-left: auto; font-size: 0.75rem;"></i>
              </a>
            </li>
            <li class="nav-item">
              <a href="#udp-telemetry" class="nav-link">
                <i class="bi bi-broadcast"></i>
                UDP Listener
              </a>
            </li>
          </ul>
        </div>
        
        <div class="nav-section">
          <div class="nav-section-title">System</div>
          <ul class="nav-list">
            <li class="nav-item">
              <a href="#" class="nav-link" id="logoutBtnSidebar">
                <i class="bi bi-box-arrow-right"></i>
                Logout
              </a>
            </li>
          </ul>
        </div>
      </aside>

      <!-- Main Content -->
      <main class="content">
        <!-- Top Bar -->
        <div class="top-bar">
          <h1 class="page-title">Admin Dashboard</h1>
          <div class="user-menu">
            <div class="user-info">
              <div class="user-avatar" id="userInitials">A</div>
              <span class="user-name" id="currentUser">Admin</span>
            </div>
            <button id="logoutBtn" class="btn btn-danger btn-sm">
              <i class="bi bi-box-arrow-right"></i> Logout
            </button>
          </div>
        </div>

        <!-- Dashboard Cards -->
        <div class="grid mb-6">
          <div class="card">
            <div class="card-body">
              <div class="info-card">
                <span class="info-card-title">Current Track</span>
                <div class="flex-between">
                  <span class="info-card-value" id="currentTrack">-</span>
                  <i class="bi bi-flag" style="font-size: 1.75rem; color: var(--primary);"></i>
                </div>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="card-body">
              <div class="info-card">
                <span class="info-card-title">Registered Drivers</span>
                <div class="flex-between">
                  <span class="info-card-value" id="driverCount">-</span>
                  <i class="bi bi-people" style="font-size: 1.75rem; color: var(--secondary);"></i>
                </div>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="card-body">
              <div class="info-card">
                <span class="info-card-title">Telemetry Status</span>
                <div class="flex-between">
                  <div id="telemetryStatusIndicator" class="status-badge">
                    <i class="bi bi-circle-fill"></i> Not Running
                  </div>
                  <i class="bi bi-broadcast" style="font-size: 1.75rem; color: var(--warning);"></i>
                </div> <!-- Will need to be fixed -->
              </div>
            </div>
          </div>
        </div>

        <!-- Track Selection -->
        <div class="card animate-in" id="trackSection">
          <div class="card-header">
            <h2 class="card-title">Track Settings</h2>
          </div>
          <div class="card-body">
            <div class="track-card" id="currentTrackDisplay">
              <div class="track-icon">
                <i class="bi bi-geo-alt"></i>
              </div>
              <div class="track-info">
                <div id="currentTrackName" class="track-name">Select a track to continue</div>
                <div class="status-badge current" id="trackStatusBadge">
                  <i class="bi bi-flag"></i> Current track
                </div>
              </div>
            </div>
            
            <form id="trackSelectForm" class="flex gap-4">
              <div class="form-group" style="flex-grow: 1; margin-bottom: 0;">
                <select id="trackSelect" class="form-control form-select">
                  <option value="">-- Select Track --</option>
                </select>
              </div>
              <button type="submit" id="setTrackBtn" class="btn btn-primary">
                <i class="bi bi-check-circle"></i> Set Track
              </button>
            </form>
            <div id="trackStatus" class="status-message"></div>
          </div>
        </div>

        <!-- Lap Times Management -->
        <div class="grid" style="grid-template-columns: 1fr 1fr;">
          <!-- Add Lap Time Form -->
          <div class="card animate-in" style="animation-delay: 0.1s">
            <div class="card-header">
              <h2 class="card-title">Add Lap Time</h2>
            </div>
            <div class="card-body">
              <form id="lapTimeForm">
                <div class="form-group">
                  <label for="driverSelect" class="form-label">Driver Name</label>
                  <select id="driverSelect" class="form-control form-select">
                    <option value="">-- Select Driver --</option>
                  </select>
                </div>
                
                <div class="form-group">
                  <label for="teamDisplay" class="form-label">Team</label>
                  <input type="text" id="teamDisplay" class="form-control" readonly disabled />
                </div>
                
                <div class="form-group">
                  <label for="lapTime" class="form-label">Lap Time</label>
                  <input 
                    type="text" 
                    id="lapTime" 
                    class="form-control" 
                    placeholder="Format: mm.ss.sss or seconds" 
                  />
                  <small style="color: var(--text-muted); display: block; margin-top: 0.5rem;">
                    <i class="bi bi-info-circle"></i> 
                    Example: 1.23.456 or 43.456
                  </small>
                </div>
                
                <div class="flex gap-2">
                  <button type="button" id="addLapBtn" class="btn btn-primary">
                    <i class="bi bi-plus-circle"></i> Add Lap Time
                  </button>
                  <button type="button" id="clearLapBtn" class="btn">
                    <i class="bi bi-x-circle"></i> Clear
                  </button>
                </div>
                <div id="addLapStatus" class="status-message"></div>
              </form>
            </div>
          </div>

          <!-- Recent Lap Times Table -->
          <div class="card animate-in" style="animation-delay: 0.2s">
            <div class="card-header">
              <h2 class="card-title">Recent Lap Times</h2>
              <button id="refreshLapTimesBtn" class="btn btn-icon">
                <i class="bi bi-arrow-clockwise"></i>
              </button>
            </div>
            <div class="card-body">
              <div class="table-responsive">
                <table id="lapTable">
                  <thead>
                    <tr>
                      <th>Driver</th>
                      <th>Team</th>
                      <th>Time</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody id="lapTableBody">
                    <!-- Lap times will be added here dynamically -->
                  </tbody>
                </table>
              </div>
            </div>
            <div class="card-footer">
              <button id="exportBtn" class="btn">
                <i class="bi bi-download"></i> Export Lap Times
              </button>
              <div id="exportStatus" class="status-message"></div>
            </div>
          </div>
        </div>

          <!-- UDP Telemetry -->
          <div class="card animate-in" id="udp-telemetry" style="animation-delay: 0.4s">
            <div class="card-header">
              <h2 class="card-title">F1 2024 Telemetry</h2>
            </div>
            <div class="card-body">
              <div class="form-group">
                <label for="udpPort" class="form-label">UDP Port:</label>
                <input type="number" id="udpPort" class="form-control" value="20777" min="1024" max="65535" />
              </div>
              <div class="flex gap-2">
                <button id="startUDPBtn" class="btn btn-primary">
                  <i class="bi bi-broadcast-pin"></i> Start UDP Listener
                </button>
                <button id="stopUDPBtn" class="btn">
                  <i class="bi bi-stop-circle"></i> Stop UDP Listener
                </button>
              </div>
              <div id="udpStatus" class="status-message"></div>
              
              <div class="telemetry-instructions">
                <h4><i class="bi bi-info-circle"></i> F1 2024 Setup Instructions:</h4>
                <ol>
                  <li>Go to F1 2024 Settings → Telemetry</li>
                  <li>Enable "UDP Telemetry Output"</li>
                  <li>Set IP Address: <code>127.0.0.1</code></li>
                  <li>Set Port: <code>20777</code> (or custom port above)</li>
                  <li>Set Send Rate: <code>20Hz or higher</code></li>
                  <li>Click "Start UDP Listener" above</li>
                </ol>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>

    <script>
      let allLapTimes = [];
      let currentTrack = "";
      let socket = null;
      let userCount = 0;
      
      document.addEventListener("DOMContentLoaded", async () => {
        // Event for track selection form
        document.getElementById("trackSelectForm").addEventListener("submit", function(e) {
          e.preventDefault();
          setTrackName();
        });
        
        // Button event listeners
        document.getElementById("addLapBtn").addEventListener("click", addLapTime);
        document.getElementById("clearLapBtn").addEventListener("click", clearLapForm);
        document.getElementById("exportBtn").addEventListener("click", exportLapTimes);
        document.getElementById("refreshLapTimesBtn").addEventListener("click", fetchLapTimes);
        document.getElementById("driverSelect").addEventListener("change", updateTeamDisplayFromSelection);
        
        // Logout button event handlers (both in top bar and sidebar)
        document.getElementById("logoutBtn").addEventListener("click", handleLogout);
        document.getElementById("logoutBtnSidebar").addEventListener("click", handleLogout);
        
        // Telemetry control buttons
        document.getElementById("startUDPBtn").addEventListener("click", startUDPTelemetry);
        document.getElementById("stopUDPBtn").addEventListener("click", stopUDPTelemetry);

        // Initialize WebSocket connection
        connectWebSocket();
        
        // Check authentication and load data
        await checkAuthStatus();
        await Promise.all([
          loadDefinedUsers(),
          loadAvailableTracks(),
          fetchCurrentTrack(),
          fetchLapTimes()
        ]);
      });      // WebSocket Implementation
      function connectWebSocket() {
        // Create WebSocket connection
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
        
        console.log(`Connecting to WebSocket at ${wsUrl}`);
        
        if (socket) {
          // Close any existing connection
          socket.close();
        }
        
        socket = new WebSocket(wsUrl);
        
        socket.onopen = (event) => {
          console.log("WebSocket connection established");
          // Update connection status in UI
          updateConnectionStatus(true);
        };
        
        socket.onmessage = (event) => {
          // Parse the JSON message
          try {
            const message = JSON.parse(event.data);
            console.log("Received WebSocket message:", message);
            handleWebSocketMessage(message);
          } catch (error) {
            console.error("Error parsing WebSocket message:", error);
          }
        };
        
        socket.onclose = (event) => {
          console.log("WebSocket connection closed");
          // Update connection status in UI
          updateConnectionStatus(false);
          // Attempt to reconnect after a delay
          setTimeout(connectWebSocket, 2000);
        };
        
        socket.onerror = (error) => {
          console.error("WebSocket error:", error);
          updateConnectionStatus(false);
          socket.close();
        };
      }
      
      // Update UI based on connection status
      function updateConnectionStatus(isConnected) {
        // Could add a connection indicator in the UI here
      }

      // Authentication functions
      async function checkAuthStatus() {
        try {
          const response = await fetch('/api/auth/status');
          if (response.ok) {
            const data = await response.json();
            if (data.authenticated) {
              const username = data.username;
              
              // Update the username display
              document.getElementById('currentUser').textContent = username;
              
              // Generate initials for the avatar
              const initials = username
                .split(' ')
                .map(name => name[0])
                .join('')
                .toUpperCase()
                .substring(0, 2);
              
              document.getElementById('userInitials').textContent = initials;
            } else {
              // Not authenticated, redirect to login
              window.location.href = '/login?next=' + encodeURIComponent(window.location.pathname);
            }
          } else {
            // Error checking auth, redirect to login
            window.location.href = '/login?next=' + encodeURIComponent(window.location.pathname);
          }
        } catch (error) {
          console.error('Error checking auth status:', error);
          // Network error, still redirect to login
          window.location.href = '/login?next=' + encodeURIComponent(window.location.pathname);
        }
      }

      async function handleLogout() {
        // Create a modern confirmation dialog
        if (!confirm('Are you sure you want to logout?')) {
          return;
        }

        try {
          const response = await fetch('/api/logout', {
            method: 'POST',
          });

          if (response.ok) {
            // Redirect to login page
            window.location.href = '/login';
          } else {
            console.error('Logout failed');
            showStatus(document.createElement('div'), 'Logout failed. Please try again.', false);
          }
        } catch (error) {
          console.error('Error during logout:', error);
          showStatus(document.createElement('div'), 'Network error during logout.', false);
        }
      }

      function handleWebSocketMessage(message) {
        switch(message.type) {
          case "user_update":
            console.log("User update received:", message);
            // Reload the user dropdown when users change
            loadDefinedUsers();
            break;
            
          case "laptime_update":
            console.log("Lap time update received:", message);
            // Refresh lap times when updates occur
            fetchLapTimes();
            break;
            
          case "track_update":
            console.log("Track update received:", message);
            // Update track display and refresh lap times
            fetchCurrentTrack();
            fetchLapTimes();
            break;
            
          case "telemetry_update":
            console.log("Telemetry update received:", message);
            // Update telemetry status
            updateTelemetryStatusIndicator(message.running);
            break;
            
          default:
            console.log("Unknown message type:", message.type);
        }
      }
      
      // Helper function for auto-hiding status messages
      function setupAutoHideStatusMessages() {
        // Find all status message containers
        const statusElements = document.querySelectorAll('.status-message');
        
        // Set up a mutation observer to watch for changes
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'childList' && mutation.target.textContent.trim() !== '') {
              const statusElement = mutation.target;
              statusElement.classList.add('visible');
              
              // Auto-hide after 5 seconds
              setTimeout(() => {
                statusElement.classList.remove('visible');
              }, 5000);
            }
          });
        });
        
        // Apply observer to all status elements
        statusElements.forEach(element => {
          observer.observe(element, { childList: true, characterData: true, subtree: true });
        });
      }

      async function loadDefinedUsers() {
        try {
          const response = await fetch("/api/users");
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          const usersArray = Object.values(data.users || {});
          usersArray.sort((a, b) => a.name.localeCompare(b.name));
          
          // Update user count in dashboard
          userCount = usersArray.length;
          document.getElementById("driverCount").textContent = userCount;
          
          populateDriverDropdown(usersArray);
        } catch (error) {
          console.error("Error loading defined users for dropdown:", error);
          populateDriverDropdown([]);
          showStatus(
            document.getElementById("addLapStatus"),
            `Error loading users: ${error.message}`,
            false
          );
        }
        updateTeamDisplayFromSelection();
      }

      function populateDriverDropdown(users) {
        const selectElement = document.getElementById("driverSelect");
        selectElement.innerHTML =
          '<option value="">-- Select Driver --</option>';

        if (!users || users.length === 0) {
          const option = document.createElement("option");
          option.textContent = "No users defined (Manage Users)";
          option.disabled = true;
          selectElement.appendChild(option);
        } else {
          users.forEach((user) => {
            const option = document.createElement("option");
            option.value = user.name;
            option.textContent = user.name;
            option.dataset.team = user.team;
            selectElement.appendChild(option);
          });
        }
      }

      function updateTeamDisplayFromSelection() {
        const selectElement = document.getElementById("driverSelect");
        const teamDisplay = document.getElementById("teamDisplay");
        const selectedOption =
          selectElement.options[selectElement.selectedIndex];

        if (selectedOption && selectedOption.dataset.team) {
          teamDisplay.value = selectedOption.dataset.team;
        } else {
          teamDisplay.value = "";
        }
      }

      async function fetchCurrentTrack() {
        try {
          const response = await fetch("/api/track");
          if (response.ok) {
            const data = await response.json();
            currentTrack = data.name || "";
            updateTrackDisplay();
          }
        } catch (error) {
          console.error("Error fetching track name:", error);
        }
      }

      function updateTrackDisplay() {
        // Update the dashboard card
        const dashboardTrackElement = document.getElementById("currentTrack");
        
        // Update the track card
        const trackNameElement = document.getElementById("currentTrackName");
        const trackStatusBadge = document.getElementById("trackStatusBadge");
        
        if (currentTrack) {
          // Format track name nicely
          const formattedTrackName = currentTrack
            .split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
            
          // Update display elements
          dashboardTrackElement.textContent = formattedTrackName;
          trackNameElement.textContent = formattedTrackName;
          
          // Show the status badge
          trackStatusBadge.style.display = "inline-flex";
        } else {
          dashboardTrackElement.textContent = "Not Set";
          trackNameElement.textContent = "No track selected";
          trackStatusBadge.style.display = "none";
        }
      }
      
      async function setTrackName() {
        const trackSelect = document.getElementById("trackSelect");
        const trackName = trackSelect.value.trim();
        const statusElement = document.getElementById("trackStatus");

        if (!trackName) {
          showStatus(statusElement, "<i class='bi bi-exclamation-triangle'></i> Please select a track", false);
          return;
        }

        try {
          const response = await fetch("/api/track", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ name: trackName }),
          });

          if (response.ok) {
            const data = await response.json();
            currentTrack = data.name;
            updateTrackDisplay();
            showStatus(
              statusElement,
              `<i class='bi bi-check-circle'></i> Track set to: ${currentTrack}`,
              true
            );
            trackSelect.value = ""; // Reset dropdown
            fetchLapTimes();
            loadDefinedUsers();
          } else {
            const errorData = await response
              .json()
              .catch(() => ({ detail: `HTTP error ${response.status}` }));
            showStatus(
              statusElement,
              `<i class='bi bi-exclamation-triangle'></i> Error: ${errorData.detail || "Failed to set track"}`,
              false
            );
          }
        } catch (error) {
          console.error("Error setting track name:", error);
          showStatus(
            statusElement,
            "<i class='bi bi-exclamation-triangle'></i> Network or server error setting track name",
            false
          );
        }
      }

      async function fetchLapTimes() {
        try {
          const response = await fetch("/api/drivers");
          if (response.ok) {
            const data = await response.json();
            updateLapTimesTable(data);
          } else {
            console.error("Failed to fetch lap times");
            updateLapTimesTable({});
            showStatus(
              document.getElementById("addLapStatus"),
              "<i class='bi bi-exclamation-triangle'></i> Failed to load lap times.",
              false
            );
          }
        } catch (error) {
          console.error("Error fetching lap times:", error);
          updateLapTimesTable({});
          showStatus(
            document.getElementById("addLapStatus"),
            `<i class='bi bi-exclamation-triangle'></i> Error loading lap times: ${error.message}`,
            false
          );
        }
      }

      async function addLapTime() {
        const driverSelect = document.getElementById("driverSelect");
        const lapTimeInput = document.getElementById("lapTime");
        const statusElement = document.getElementById("addLapStatus");
        const teamDisplay = document.getElementById("teamDisplay");

        const driverName = driverSelect.value;
        const team = teamDisplay.value;
        const lapTime = lapTimeInput.value.trim();

        if (!driverName) {
          showStatus(statusElement, "<i class='bi bi-exclamation-triangle'></i> Please select a driver", false);
          return;
        }
        if (!lapTime) {
          showStatus(statusElement, "<i class='bi bi-exclamation-triangle'></i> Please enter lap time", false);
          return;
        }
        if (!team) {
          showStatus(
            statusElement,
            "<i class='bi bi-exclamation-triangle'></i> Could not determine team for selected driver.",
            false
          );
          return;
        }

        try {
          const response = await fetch("/api/laptime", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              name: driverName,
              team: team,
              time: lapTime,
            }),
          });

          if (response.ok) {
            showStatus(statusElement, "<i class='bi bi-check-circle'></i> Lap time added successfully", true);
            clearLapForm();
            fetchLapTimes();
          } else {
            const errorData = await response
              .json()
              .catch(() => ({ detail: "Failed to add lap time" }));
            const errorMessage = errorData.detail || "Failed to add lap time";
            const displayMessage = Array.isArray(errorMessage)
              ? errorMessage
                  .map(
                    (e) =>
                      `${e.loc ? e.loc.join(".") + ": " : ""}${e.msg}`
                  )
                  .join(", ")
              : errorMessage;
            showStatus(
              statusElement,
              `<i class='bi bi-exclamation-triangle'></i> Error: ${displayMessage}`,
              false
            );
          }
        } catch (error) {
          console.error("Error adding lap time:", error);
          showStatus(
            statusElement,
            "<i class='bi bi-exclamation-triangle'></i> Network or server error adding lap time",
            false
          );
        }
      }

      function clearLapForm() {
        document.getElementById("driverSelect").value = "";
        document.getElementById("lapTime").value = "";
        document.getElementById("teamDisplay").value = "";
        document.getElementById("addLapStatus").innerHTML = "";
      }

      function updateLapTimesTable(drivers) {
        const tableBody = document.getElementById("lapTableBody");
        tableBody.innerHTML = "";

        allLapTimes = [];

        if (
          drivers &&
          typeof drivers === "object" &&
          Object.keys(drivers).length > 0
        ) {
          for (const [name, driver] of Object.entries(drivers)) {
            // Correctly check the lap_times array
            if (driver.lap_times && driver.lap_times.length > 0) {
              const fastestLap = driver.lap_times[0]; // Get the first (and only) lap
              allLapTimes.push({
                driver: name,
                team: driver.team,
                time: fastestLap.time, // Access time from the lap object
                // Optionally store seconds for correct sorting:
                time_seconds: fastestLap.time_seconds
              });
            }
          }
          // Correct sorting using time_seconds
          allLapTimes.sort((a, b) => a.time_seconds - b.time_seconds);
        }

        if (allLapTimes.length === 0) {
          const row = tableBody.insertRow();
          const cell = row.insertCell();
          cell.colSpan = 4;
          cell.textContent = "No lap times recorded yet for this track.";
          cell.style.textAlign = "center";
          cell.style.fontStyle = "italic";
          cell.style.color = "var(--text-muted)";
          cell.style.padding = "2rem 1rem";
        } else {
          for (let i = 0; i < allLapTimes.length; i++) {
            const lap = allLapTimes[i];
            const row = document.createElement("tr");
            
            // Create position indicator for top 3
            let positionHTML = '';
            if (i === 0) {
              positionHTML = '<span class="status-badge" style="background: rgba(255,215,0,0.2); color: gold;"><i class="bi bi-trophy-fill"></i> 1st</span>';
            } else if (i === 1) {
              positionHTML = '<span class="status-badge" style="background: rgba(192,192,192,0.2); color: silver;"><i class="bi bi-trophy"></i> 2nd</span>';
            } else if (i === 2) {
              positionHTML = '<span class="status-badge" style="background: rgba(205,127,50,0.2); color: #cd7f32;"><i class="bi bi-trophy"></i> 3rd</span>';
            }
            
            // Create team pill
            const teamClass = `team-${lap.team.replace(/\s+/g, '')}`;
            
            // Escape driver name for safety in onclick attribute
            const escapedDriverName = lap.driver
              .replace(/'/g, "\\'")
              .replace(/"/g, "&quot;");
              
            row.innerHTML = `
              <td>
                ${lap.driver}
                ${positionHTML}
              </td>
              <td><span class="pill ${teamClass}">${lap.team}</span></td>
              <td><strong>${formatTime(lap.time)}</strong></td>
              <td>
                <button 
                  onclick="deleteLapTime('${escapedDriverName}', '${lap.time}')" 
                  class="btn btn-danger btn-sm"
                  style="padding: 0.25rem 0.5rem;"
                >
                  <i class="bi bi-trash"></i>
                </button>
              </td>
            `;
            tableBody.appendChild(row);
          }
        }
      }

      async function deleteLapTime(driver, time) {
        if (
          !confirm(
            `Are you sure you want to delete the lap time ${formatTime(
              time
            )} for ${driver}?`
          )
        ) {
          return;
        }

        try {
          const response = await fetch("/api/laptime", {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              name: driver,
              time: time,
            }),
          });

          if (response.ok) {
            fetchLapTimes();
            showStatus(
              document.getElementById("addLapStatus"),
              "<i class='bi bi-check-circle'></i> Lap time deleted successfully.",
              true
            );
          } else {
            const errorData = await response
              .json()
              .catch(() => ({ detail: "Failed to delete lap time" }));
            showStatus(
              document.getElementById("addLapStatus"),
              `<i class='bi bi-exclamation-triangle'></i> Error: ${errorData.detail}`,
              false
            );
            console.error("Failed to delete lap time", errorData);
          }
        } catch (error) {
          showStatus(
            document.getElementById("addLapStatus"),
            "<i class='bi bi-exclamation-triangle'></i> Network or server error deleting lap time.",
            false
          );
          console.error("Error deleting lap time:", error);
        }
      }      async function exportLapTimes() {
        const statusElement = document.getElementById("exportStatus");

        if (!currentTrack) {
          showStatus(
            statusElement,
            "<i class='bi bi-exclamation-triangle'></i> Please set a track name before exporting",
            false
          );
          return;
        }

        showStatus(statusElement, "<i class='bi bi-cloud-download'></i> Exporting...", true);

        try {
          const response = await fetch("/api/export");

          if (response.ok) {
            // Check if the response is a CSV file
            const contentType = response.headers.get("content-type");
            if (contentType && contentType.includes("text/csv")) {
              // Get the filename from Content-Disposition header
              const contentDisposition = response.headers.get("content-disposition");
              let filename = "export.csv";
              if (contentDisposition) {
                const filenameMatch = contentDisposition.match(/filename=(.+)/);
                if (filenameMatch) {
                  filename = filenameMatch[1];
                }
              }

              // Create blob and download the file
              const blob = await response.blob();
              const url = window.URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = filename;
              document.body.appendChild(a);
              a.click();
              window.URL.revokeObjectURL(url);
              document.body.removeChild(a);

              showStatus(
                statusElement,
                `<i class='bi bi-check-circle'></i> Export successful! File downloaded: ${filename}`,
                true
              );
            } else {
              // Handle error response (JSON)
              const errorData = await response.json();
              showStatus(
                statusElement,
                `<i class='bi bi-exclamation-triangle'></i> Export failed: ${errorData.error || "Unknown error"}`,
                false
              );
            }
          } else {
            // Handle HTTP error responses
            const errorData = await response
              .json()
              .catch(() => ({ error: `HTTP error ${response.status}` }));
            showStatus(
              statusElement,
              `<i class='bi bi-exclamation-triangle'></i> Export failed: ${errorData.error || "Server error"}`,
              false
            );
          }
        } catch (error) {
          console.error("Error calling export API:", error);
          showStatus(
            statusElement,
            "<i class='bi bi-exclamation-triangle'></i> Network or server error during export",
            false
          );
        }
      }

      // Function to update telemetry status indicator in dashboard
      function updateTelemetryStatusIndicator(isRunning) {
        const indicator = document.getElementById('telemetryStatusIndicator');
        
        if (isRunning) {
          indicator.innerHTML = '<i class="bi bi-broadcast-pin"></i> Running';
          indicator.className = 'status-badge active';
        } else {
          indicator.innerHTML = '<i class="bi bi-circle"></i> Not Running';
          indicator.className = 'status-badge';
        }
      }

      // Telemetry Demo Controls
      async function startTelemetryDemo() {
        const statusElement = document.getElementById("telemetryStatus");
        showStatus(statusElement, "<i class='bi bi-hourglass-split'></i> Starting telemetry demo...", true);

        try {
          const response = await fetch("/api/telemetry/demo/start", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            }
          });

          if (response.ok) {
            const data = await response.json();
            showStatus(statusElement, `<i class='bi bi-check-circle'></i> ${data.message}`, true);
            updateTelemetryStatusIndicator(true);
          } else {
            const errorData = await response.json().catch(() => ({ detail: "Failed to start telemetry demo" }));
            showStatus(statusElement, `<i class='bi bi-exclamation-triangle'></i> Error: ${errorData.detail}`, false);
          }
        } catch (error) {
          console.error("Error starting telemetry demo:", error);
          showStatus(statusElement, "<i class='bi bi-exclamation-triangle'></i> Network error starting telemetry demo", false);
        }
      }

      async function stopTelemetryDemo() {
        const statusElement = document.getElementById("telemetryStatus");
        showStatus(statusElement, "<i class='bi bi-hourglass-split'></i> Stopping telemetry demo...", true);

        try {
          const response = await fetch("/api/telemetry/demo/stop", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            }
          });

          if (response.ok) {
            const data = await response.json();
            showStatus(statusElement, `<i class='bi bi-check-circle'></i> ${data.message}`, true);
            updateTelemetryStatusIndicator(false);
          } else {
            const errorData = await response.json().catch(() => ({ detail: "Failed to stop telemetry demo" }));
            showStatus(statusElement, `<i class='bi bi-exclamation-triangle'></i> Error: ${errorData.detail}`, false);
          }
        } catch (error) {
          console.error("Error stopping telemetry demo:", error);
          showStatus(statusElement, "<i class='bi bi-exclamation-triangle'></i> Network error stopping telemetry demo", false);
        }
      }

      // UDP Telemetry Functions
      async function startUDPTelemetry() {
        const statusElement = document.getElementById("udpStatus");
        const portInput = document.getElementById("udpPort");
        const port = parseInt(portInput.value) || 20777;

        showStatus(statusElement, "<i class='bi bi-hourglass-split'></i> Starting UDP telemetry listener...", true);

        try {
          const response = await fetch(`/api/telemetry/start?port=${port}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            }
          });

          if (response.ok) {
            const data = await response.json();
            showStatus(statusElement, `<i class='bi bi-check-circle'></i> ${data.message}`, true);
            updateTelemetryStatusIndicator(true);
          } else {
            const errorData = await response.json().catch(() => ({ detail: "Failed to start UDP telemetry" }));
            showStatus(statusElement, `<i class='bi bi-exclamation-triangle'></i> Error: ${errorData.detail}`, false);
          }
        } catch (error) {
          console.error("Error starting UDP telemetry:", error);
          showStatus(statusElement, "<i class='bi bi-exclamation-triangle'></i> Network error starting UDP telemetry", false);
        }
      }

      async function stopUDPTelemetry() {
        const statusElement = document.getElementById("udpStatus");
        showStatus(statusElement, "<i class='bi bi-hourglass-split'></i> Stopping UDP telemetry...", true);

        try {
          const response = await fetch("/api/telemetry/stop", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            }
          });

          if (response.ok) {
            const data = await response.json();
            showStatus(statusElement, `<i class='bi bi-check-circle'></i> ${data.message}`, true);
            updateTelemetryStatusIndicator(false);
          } else {
            const errorData = await response.json().catch(() => ({ detail: "Failed to stop UDP telemetry" }));
            showStatus(statusElement, `<i class='bi bi-exclamation-triangle'></i> Error: ${errorData.detail}`, false);
          }
        } catch (error) {
          console.error("Error stopping UDP telemetry:", error);
          showStatus(statusElement, "<i class='bi bi-exclamation-triangle'></i> Network error stopping UDP telemetry", false);
        }
      }

      // Helper function to show status messages
      function showStatus(element, message, isSuccess) {
        element.innerHTML = message;
        element.className = 'status-message ' + (isSuccess ? 'status-success' : 'status-error') + ' visible';
        
        // Clear message after a delay (now handled by CSS transitions)
        setTimeout(() => {
          // Only clear if the message hasn't changed in the meantime
          if (element.innerHTML === message) {
            element.classList.remove('visible');
          }
        }, 5000); // 5 second delay
      }
      
      // Time formatting function
      function formatTime(timeInput) {
        let totalSeconds;

        if (typeof timeInput === "string") {
          if (timeInput.includes(":")) {
            const parts = timeInput.split(/[:.]/);
            if (parts.length === 3) {
              totalSeconds =
                parseInt(parts[0]) * 60 +
                parseInt(parts[1]) +
                parseFloat(`0.${parts[2]}`);
            } else if (parts.length === 2) {
              totalSeconds =
                parseInt(parts[0]) * 60 + parseInt(parts[1]);
            } else {
              totalSeconds = parseFloat(timeInput);
            }
          } else if (timeInput.includes(".")) {
            const parts = timeInput.split(".");
            if (parts.length === 3) {
              totalSeconds =
                parseInt(parts[0]) * 60 +
                parseInt(parts[1]) +
                parseFloat(`0.${parts[2]}`);
            } else {
              totalSeconds = parseFloat(timeInput);
            }
          } else {
            totalSeconds = parseFloat(timeInput);
          }
        } else if (typeof timeInput === "number") {
          totalSeconds = timeInput;
        } else {
          return "N/A";
        }

        if (
          isNaN(totalSeconds) ||
          totalSeconds === Infinity ||
          totalSeconds < 0
        ) {
          return "N/A";
        }

        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const formattedSeconds =
          seconds < 10 ? `0${seconds.toFixed(3)}` : seconds.toFixed(3);

        return `${minutes}:${formattedSeconds}`;
      }

      async function loadAvailableTracks() {
        try {
          const response = await fetch("/api/tracks");
          if (response.ok) {
            const tracks = await response.json();
            const trackSelect = document.getElementById("trackSelect");
            
            // Clear existing options except the first one
            while (trackSelect.children.length > 1) {
              trackSelect.removeChild(trackSelect.lastChild);
            }
            
            // Sort tracks alphabetically
            tracks.sort();
            
            // Add tracks to dropdown with nicer formatting
            tracks.forEach(track => {
              const option = document.createElement("option");
              option.value = track;
              
              // Format the track name nicely
              const formattedName = track
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
                
              option.textContent = formattedName;
              trackSelect.appendChild(option);
            });
          } else {
            console.error("Failed to fetch available tracks");
          }
        } catch (error) {
          console.error("Error loading available tracks:", error);
        }
      }
    </script>
  </body>
</html>
