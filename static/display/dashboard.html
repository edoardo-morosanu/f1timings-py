<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>F1 24 Dashboard - Track Map & Leaderboard</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;600;700&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Orbitron", "Arial", sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      color: #ffffff;
      height: 100vh;
      overflow: hidden;
    }

    .dashboard-container {
      display: grid;
      grid-template-columns: 380px 1fr;
      grid-template-rows: 70px calc(100vh - 110px);
      height: 100vh;
      gap: 20px;
      padding: 20px;
    }

    /* Header */
    .header {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(30, 30, 50, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 0 24px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .header img {
      height: 50px;
      width: auto;
      max-width: 120px;
      object-fit: contain;
      border-radius: 4px;
    }

    .header h1 {
      font-size: 24px;
      font-weight: 700;
      letter-spacing: 1px;
    }

    .track-title {
      color: #ef4444;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background-color: #065f46;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background-color: #10b981;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Leaderboard */
    .leaderboard {
      background: rgba(30, 30, 50, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      height: 98%;
      min-height: 0;
    }

    .leaderboard-header {
      padding: 20px;
      background: rgba(20, 20, 35, 0.8);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }

    .leaderboard-title {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 8px;
      color: #ffffff;
    }

    .leaderboard-subtitle {
      font-size: 12px;
      color: #a0a0b0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .leaderboard-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      min-height: 0;
    }

    .driver-row {
      display: grid;
      grid-template-columns: 40px 1fr 80px;
      gap: 12px;
      align-items: center;
      padding: 16px 20px;
      margin-bottom: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .driver-row::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 12px;
      padding: 1px;
      background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite: exclude;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .driver-row:hover::before {
      opacity: 1;
    }

    .driver-row:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    }

    .driver-row.fastest {
      border: 1px solid rgba(168, 85, 247, 0.4);
      box-shadow: 0 0 30px rgba(168, 85, 247, 0.2);
    }

    .driver-row.redbull {
      background: linear-gradient(135deg, rgba(6, 0, 239, 0.15) 0%, rgba(30, 64, 175, 0.05) 100%);
    }

    .driver-row.mclaren {
      background: linear-gradient(135deg, rgba(255, 135, 0, 0.15) 0%, rgba(245, 158, 11, 0.05) 100%);
    }

    .position {
      font-size: 20px;
      font-weight: 800;
      text-align: center;
      color: #ffffff;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .driver-info {
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .driver-name {
      font-size: 16px;
      font-weight: 600;
      color: #ffffff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 2px;
    }

    .driver-team {
      font-size: 11px;
      color: #a0a0b0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .lap-time {
      font-family: "Roboto Mono", "Courier New", monospace;
      font-size: 16px;
      font-weight: 700;
      text-align: right;
      color: #ffffff;
    }

    .lap-time.fastest {
      color: #a855f7;
      text-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
    }

    /* Track Map */
    .track-container {
      display: flex;
      flex-direction: column;
      height: 98%;
      min-height: 0;
    }

    .track-header {
      padding: 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(30, 30, 50, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      margin-bottom: 20px;
      flex-shrink: 0;
    }

    .track-title-section {
      display: flex;
      flex-direction: column;
    }

    .track-name {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 4px;
      color: #ffffff;
    }

    .track-info {
      font-size: 12px;
      color: #a0a0b0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .fastest-lap-info {
      text-align: right;
    }

    .fastest-lap-label {
      font-size: 12px;
      color: #a855f7;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .fastest-lap-time {
      font-family: "Roboto Mono", "Courier New", monospace;
      font-size: 18px;
      font-weight: 700;
      color: #a855f7;
      text-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
    }    .track-map {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
      border-radius: 15px;
      background: rgba(30, 30, 50, 0.3);
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.05);
      width: 100%;
      min-height: 0;
    }    #trackCanvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 8px;
    }

    .track-placeholder {
      width: 100%;
      height: 100%;
      max-width: 600px;
      max-height: 400px;
      border: 2px dashed rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: #a0a0b0;
      font-size: 16px;
      font-weight: 600;
      position: relative;
      overflow: hidden;
    }

    .track-placeholder::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(168, 85, 247, 0.1), transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    .track-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.6;
    }

    /* No data states */
    .no-data {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 200px;
      color: #a0a0b0;
      font-style: italic;
    }

    /* Scrollbar styles */
    .leaderboard-content::-webkit-scrollbar {
      width: 8px;
    }

    .leaderboard-content::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 4px;
    }

    .leaderboard-content::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
    }

    .leaderboard-content::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Responsive adjustments */
    @media (max-width: 1200px) {
      .dashboard-container {
        grid-template-columns: 320px 1fr;
      }
    }

    @media (max-width: 768px) {
      .dashboard-container {
        grid-template-columns: 1fr;
        grid-template-rows: 70px 350px 1fr;
        gap: 15px;
        padding: 15px;
      }
      
      .header h1 {
        font-size: 18px;
      }
      
      .header img {
        height: 40px;
      }
    }
  </style>
</head>
<body>
  <div class="dashboard-container">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <img src="img/NHLStenden.png" alt="NHLStenden Logo" />
        <h1>
          F1(24) <span id="trackTitle" class="track-title">DASHBOARD</span>
        </h1>
      </div>
      <div class="header-right">
        <div class="status-indicator">
          <div class="status-dot"></div>
          <span>LIVE</span>
        </div>
        <img src="img/HBOSport.png" alt="HBO Sport Logo" />
      </div>
    </header>

    <!-- Leaderboard -->
    <div class="leaderboard">
      <div class="leaderboard-header">
        <div class="leaderboard-title">Live Timing</div>
        <div class="leaderboard-subtitle">Fastest Lap Times</div>
      </div>
      <div class="leaderboard-content" id="leaderboardContent">
        <div class="no-data">
          <div style="font-size: 24px; margin-bottom: 12px;">⏱️</div>
          <div>No timing data available</div>
        </div>
      </div>
    </div>

    <!-- Track Map -->
    <div class="track-container">
      <div class="track-header">
        <div class="track-title-section">
          <div class="track-name" id="trackName">Circuit Name</div>
          <div class="track-info">Track Map</div>
        </div>
        <div class="fastest-lap-info" id="fastestLapInfo" style="display: none;">
          <div class="fastest-lap-label">Fastest Lap</div>
          <div class="fastest-lap-time" id="fastestLapTime">--:--.---</div>
        </div>
      </div>      <div class="track-map">
        <canvas id="trackCanvas" width="900" height="600" style="display: none;"></canvas>
        <div class="track-placeholder" id="trackPlaceholder">
          <div class="track-icon">🏁</div>
          <div>Track Map Placeholder</div>
          <div style="font-size: 12px; margin-top: 8px; opacity: 0.7;">
            Track visualization will appear here
          </div>
        </div>
      </div>
    </div>
  </div>  <script>
    // Global variables
    let currentTrack = "";
    let trackData = null;
    let allDriverData = {};
    let socket;
    let canvas, ctx;
    let driverMarkers = {};
    let currentDriverPositions = {};    let currentDriverInfo = {};
    let currentSessionType = null;
    
    // Session type mapping (F1 2024 UDP spec)
    const SESSION_TYPES = {
      0: 'Unknown',
      1: 'Practice 1',
      2: 'Practice 2', 
      3: 'Practice 3',
      4: 'Short Practice',
      5: 'Qualifying 1',
      6: 'Qualifying 2',
      7: 'Qualifying 3',
      8: 'Short Qualifying',
      9: 'OSQ',
      10: 'Race',
      11: 'Race 2',
      12: 'Race 3',
      13: 'Time Trial'
    };
    
    // Team colors for driver markers (matching backend)
    const TEAM_COLORS = {
      'Mercedes-AMG Petronas F1 Team': '#00D2BE',
      'Scuderia Ferrari': '#DC0000',
      'Oracle Red Bull Racing': '#0600EF',
      'Williams Racing': '#005AFF',
      'Aston Martin Aramco F1 Team': '#006F62',
      'BWT Alpine F1 Team': '#0090FF',
      'Visa Cash App RB F1 Team': '#2B4562',
      'MoneyGram Haas F1 Team': '#FFFFFF',
      'McLaren F1 Team': '#FF8700',
      'Stake F1 Team Kick Sauber': '#52E252',
      'DEFAULT': '#FF00FF' // Default color if team not found (Magenta)
    };

    // Track dictionary with scaling parameters (matching reference implementation)
    const TRACK_DICTIONARY = {
      'abu_dhabi': { d: 2, x_offset: 800, z_offset: 400 },
      'austria': { d: 2, x_offset: 800, z_offset: 400 },
      'bahrain': { d: 2, x_offset: 800, z_offset: 400 },
      'baku': { d: 3, x_offset: 800, z_offset: 400 },
      'brazil': { d: 2, x_offset: 800, z_offset: 300 },
      'catalunya': { d: 2.5, x_offset: 800, z_offset: 400 },
      'hanoi': { d: 2.5, x_offset: 800, z_offset: 400 },
      'hockenheim': { d: 2, x_offset: 800, z_offset: 400 },
      'hungaroring': { d: 2.5, x_offset: 800, z_offset: 400 },
      'imola': { d: 2, x_offset: 800, z_offset: 400 },
      'jeddah': { d: 4, x_offset: 800, z_offset: 400 },
      'las_vegas': { d: 4, x_offset: 800, z_offset: 400 },
      'losail': { d: 2.5, x_offset: 800, z_offset: 400 },
      'melbourne': { d: 3.5, x_offset: 800, z_offset: 400 },
      'mexico': { d: 2.5, x_offset: 800, z_offset: 600 },
      'miami': { d: 2, x_offset: 800, z_offset: 400 },
      'monaco': { d: 2, x_offset: 800, z_offset: 400 },
      'montreal': { d: 3, x_offset: 800, z_offset: 200 },
      'monza': { d: 4, x_offset: 800, z_offset: 400 },
      'paul_ricard': { d: 2.5, x_offset: 800, z_offset: 400 },
      'portimao': { d: 2, x_offset: 800, z_offset: 400 },
      'sakhir': { d: 2, x_offset: 800, z_offset: 400 },
      'shanghai': { d: 2, x_offset: 800, z_offset: 400 },
      'silverstone': { d: 3.5, x_offset: 800, z_offset: 400 },
      'silverstone_short': { d: 2, x_offset: 800, z_offset: 400 },
      'singapore': { d: 2, x_offset: 800, z_offset: 400 },
      'sochi': { d: 2, x_offset: 800, z_offset: 400 },
      'spa': { d: 3.5, x_offset: 800, z_offset: 400 },
      'suzuka': { d: 2.5, x_offset: 800, z_offset: 400 },
      'suzuka_short': { d: 2, x_offset: 800, z_offset: 400 },
      'texas': { d: 2, x_offset: 800, z_offset: 200 },
      'texas_short': { d: 2, x_offset: 800, z_offset: 400 },
      'zandvoort': { d: 2, x_offset: 800, z_offset: 400 }    };
    
    let fetchDataInterval = null;
    const FETCH_INTERVAL_MS = 17; // Fetch data every 0.017 seconds (same as track.html)
    const DRIVER_DOT_RADIUS = 8; // Size of driver dots on the track

    document.addEventListener("DOMContentLoaded", () => {
      canvas = document.getElementById("trackCanvas");
      ctx = canvas.getContext("2d");
      
      console.log("Canvas initialized:", canvas);
      console.log("Canvas dimensions:", canvas.width, "x", canvas.height);
      console.log("Context:", ctx);
      
      // Initialize WebSocket for real-time updates
      initializeWebSocket();
      
      // Load current track and lap times
      loadCurrentTrack();
      
      // Start periodic data fetching
      startDataFetching();
    });

    function startDataFetching() {
      // Clear any existing interval
      if (fetchDataInterval) {
        clearInterval(fetchDataInterval);
      }
      
      // Initial data load
      loadDisplayData();
      
      // Set up the interval for regular updates
      fetchDataInterval = setInterval(() => {
        loadDisplayData();
      }, FETCH_INTERVAL_MS);
    }    async function loadDisplayData() {
      try {
        // Fetch driver data
        const response = await fetch("/api/drivers");
        const drivers = await response.json();

        allDriverData = drivers;
        const processedDrivers = processDriverData(drivers);

        updateLeaderboard(processedDrivers);
        updateFastestLapInfo(processedDrivers);
        
        // Fetch session data for session type
        await loadSessionData();
        
        // Draw drivers on track if canvas is ready
        if (canvas && ctx && trackData) {
          drawDriversOnTrack(drivers);
        }
      } catch (error) {
        console.error("Error loading display data:", error);
      }
    }

    function processDriverData(drivers) {
      const processed = {};
      let overallFastestTimeValue = Infinity;
      let overallFastestLapKey = null;

      // Find overall fastest lap
      for (const [name, driver] of Object.entries(drivers)) {
        if (driver.lap_times.length > 0) {
          driver.lap_times.forEach((lap, index) => {
            const timeValue = parseTimeToSeconds(lap.time);
            if (timeValue < overallFastestTimeValue) {
              overallFastestTimeValue = timeValue;
              overallFastestLapKey = `${name}_${index}`;
            }
          });
        }
      }

      // Process each driver
      for (const [name, driver] of Object.entries(drivers)) {
        processed[name] = { ...driver, lap_times: [] };

        if (driver.lap_times.length > 0) {
          const lapsWithData = driver.lap_times.map((lap, index) => ({
            ...lap,
            originalIndex: index,
            timeValue: parseTimeToSeconds(lap.time)
          }));

          lapsWithData.sort((a, b) => a.timeValue - b.timeValue);
          const fastestLapForDriver = lapsWithData[0];
          const currentLapKey = `${name}_${fastestLapForDriver.originalIndex}`;
          fastestLapForDriver.is_fastest = (currentLapKey === overallFastestLapKey);

          processed[name].lap_times = [fastestLapForDriver];
        }
      }
      return processed;
    }

    function updateLeaderboard(drivers) {
      const container = document.getElementById("leaderboardContent");
      
      const allDrivers = Object.entries(drivers).filter(([name, driver]) => 
        driver.lap_times.length > 0
      );

      if (allDrivers.length === 0) {
        container.innerHTML = `
          <div class="no-data">
            <div style="font-size: 24px; margin-bottom: 12px;">⏱️</div>
            <div>No timing data available</div>
          </div>
        `;
        return;
      }

      // Sort by lap time
      allDrivers.sort((a, b) => {
        const timeA = parseTimeToSeconds(a[1].lap_times[0].time);
        const timeB = parseTimeToSeconds(b[1].lap_times[0].time);
        return timeA - timeB;
      });

      let html = "";
      allDrivers.forEach(([name, driver], index) => {
        const lap = driver.lap_times[0];
        const position = index + 1;
        const teamClass = driver.team.toLowerCase();
        const isFastest = lap.is_fastest;        html += `
          <div class="driver-row ${isFastest ? 'fastest' : ''} ${teamClass}">
            <div class="position">${position}</div>
            <div class="driver-info">
              <div class="driver-name">${truncateName(driver.name, 25)}</div>
              <div class="driver-team">${driver.team}</div>
            </div>
            <div class="lap-time ${isFastest ? 'fastest' : ''}">${formatTime(lap.time)}</div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    function updateFastestLapInfo(drivers) {
      const fastestLapInfo = document.getElementById("fastestLapInfo");
      const fastestLapTime = document.getElementById("fastestLapTime");
      
      let fastestTime = null;
      
      for (const [name, driver] of Object.entries(drivers)) {
        if (driver.lap_times.length > 0 && driver.lap_times[0].is_fastest) {
          fastestTime = driver.lap_times[0].time;
          break;
        }
      }
      
      if (fastestTime) {
        fastestLapInfo.style.display = "block";
        fastestLapTime.textContent = formatTime(fastestTime);
      } else {
        fastestLapInfo.style.display = "none";
      }
    }

    function parseTimeToSeconds(timeString) {
      if (timeString.includes(':')) {
        const parts = timeString.split(/[:.]/);
        if (parts.length === 3) {
          return parseInt(parts[0]) * 60 + parseInt(parts[1]) + parseFloat(`0.${parts[2]}`);
        } else if (parts.length === 2) {
          return parseInt(parts[0]) * 60 + parseInt(parts[1]);
        }
      } else if (timeString.includes('.')) {
        const parts = timeString.split('.');
        if (parts.length === 3) {
          return parseInt(parts[0]) * 60 + parseInt(parts[1]) + parseFloat(`0.${parts[2]}`);
        } else if (parts.length === 2) {
          return parseFloat(timeString);
        }
      }
      const parsed = parseFloat(timeString);
      return isNaN(parsed) ? Infinity : parsed;
    }

    function truncateName(name, maxLength) {
      if (!name) return "";
      if (name.length <= maxLength) {
        return name;
      }
      let truncated = name.substring(0, maxLength);
      let lastSpace = truncated.lastIndexOf(' ');
      if (lastSpace > maxLength / 2) {
        return truncated.substring(0, lastSpace) + '...';
      }
      return truncated + '...';
    }

    function formatTime(timeInput) {
      let totalSeconds;

      if (typeof timeInput === 'string') {
        if (timeInput.includes(':')) {
          const parts = timeInput.split(/[:.]/);
          if (parts.length === 3) {
            totalSeconds = parseInt(parts[0]) * 60 + parseInt(parts[1]) + parseFloat(`0.${parts[2]}`);
          } else if (parts.length === 2) {
            totalSeconds = parseInt(parts[0]) * 60 + parseInt(parts[1]);
          } else {
            totalSeconds = parseFloat(timeInput);
          }
        } else if (timeInput.includes('.')) {
          const parts = timeInput.split('.');
          if (parts.length === 3) {
            totalSeconds = parseInt(parts[0]) * 60 + parseInt(parts[1]) + parseFloat(`0.${parts[2]}`);
          } else {
            totalSeconds = parseFloat(timeInput);
          }
        } else {
          totalSeconds = parseFloat(timeInput);
        }
      } else if (typeof timeInput === 'number') {
        totalSeconds = timeInput;
      } else {
        return "N/A";
      }

      if (isNaN(totalSeconds) || totalSeconds === Infinity) {
        return "N/A";
      }

      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const formattedSeconds = seconds < 10 ? `0${seconds.toFixed(3)}` : seconds.toFixed(3);

      return `${minutes}:${formattedSeconds}`;
    }    function drawTrackOnCanvas(trackData, params) {
      console.log(`Drawing track on canvas with params:`, params);
      const { d, x_offset, z_offset } = params;
      const points = trackData.points;
      
      console.log(`Track has ${points.length} points`);
        if (points.length < 2) {
        console.warn('Not enough points to draw track');
        displayNoTrackData();
        return;
      }

      // Clear canvas completely
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Set line style - simple white line (thicker for better visibility)
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#FFFFFF';

      // Transform coordinates using the exact same algorithm as reference
      const transformedPoints = points.map(point => ({
        x: (point.pos_z / d) + x_offset,
        y: (point.pos_x / d) + z_offset
      }));

      // Calculate bounds of transformed points
      const minX = Math.min(...transformedPoints.map(p => p.x));
      const maxX = Math.max(...transformedPoints.map(p => p.x));
      const minY = Math.min(...transformedPoints.map(p => p.y));
      const maxY = Math.max(...transformedPoints.map(p => p.y));
      
      // Calculate track dimensions
      const trackWidth = maxX - minX;
      const trackHeight = maxY - minY;
      
      // Calculate scale to fit track in canvas with padding
      const padding = 40;
      const availableWidth = canvas.width - (2 * padding);
      const availableHeight = canvas.height - (2 * padding);
      const scale = Math.min(availableWidth / trackWidth, availableHeight / trackHeight);
      
      // Calculate centering offsets
      const scaledWidth = trackWidth * scale;
      const scaledHeight = trackHeight * scale;
      const centerOffsetX = (canvas.width - scaledWidth) / 2;
      const centerOffsetY = (canvas.height - scaledHeight) / 2;

      // Apply centering and scaling to all points
      const centeredPoints = transformedPoints.map(point => ({
        x: (point.x - minX) * scale + centerOffsetX,
        y: (point.y - minY) * scale + centerOffsetY
      }));

      // Draw track as one continuous white line
      ctx.beginPath();
      centeredPoints.forEach((point, index) => {
        if (index === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      
      // Close the track loop
      if (centeredPoints.length > 0) {
        ctx.lineTo(centeredPoints[0].x, centeredPoints[0].y);
      }      
      ctx.stroke();
        // Store the transformation parameters for driver positioning
      trackData.transformParams = {
        minX: minX,
        minY: minY,
        scale: scale,
        centerOffsetX: centerOffsetX,
        centerOffsetY: centerOffsetY      };
    }
    
    function redrawTrackOnly() {
      if (!trackData || !trackData.points) {
        return;
      }
      
      const trackParams = TRACK_DICTIONARY[currentTrack.toLowerCase()];
      if (!trackParams) {
        return;
      }
        const { d, x_offset, z_offset } = trackParams;
      const points = trackData.points;
      
      // Clear canvas completely
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Set line style - simple white line (thicker for better visibility)
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#FFFFFF';

      // Transform coordinates using the exact same algorithm as reference
      const transformedPoints = points.map(point => ({
        x: (point.pos_z / d) + x_offset,
        y: (point.pos_x / d) + z_offset
      }));

      // Use stored transformation parameters
      const { minX, minY, scale, centerOffsetX, centerOffsetY } = trackData.transformParams;

      // Apply centering and scaling to all points
      const centeredPoints = transformedPoints.map(point => ({
        x: (point.x - minX) * scale + centerOffsetX,
        y: (point.y - minY) * scale + centerOffsetY
      }));

      // Draw track as one continuous white line
      ctx.beginPath();
      centeredPoints.forEach((point, index) => {
        if (index === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      
      // Close the track loop
      if (centeredPoints.length > 0) {
        ctx.lineTo(centeredPoints[0].x, centeredPoints[0].y);
      }
      
      ctx.stroke();
    }
      function drawDriversOnTrack(driversData) {
      if (!canvas || !ctx || !trackData || !trackData.transformParams) {
        return; // Not ready to draw drivers yet
      }
      
      const trackParams = TRACK_DICTIONARY[currentTrack.toLowerCase()];
      if (!trackParams) {
        return; // No track parameters available
      }
      
      // Redraw the track first (without triggering recursive calls)
      redrawTrackOnly();
      
      const { d, x_offset, z_offset } = trackParams;
      const { minX, minY, scale, centerOffsetX, centerOffsetY } = trackData.transformParams;
        // Draw each driver that has position data
      for (const [driverName, driver] of Object.entries(driversData)) {        // Skip if no position data available
        if (driver.world_x === undefined || driver.world_z === undefined) {
          continue;
        }
          // Transform driver coordinates using the same algorithm as the track points
        // Game's X-coordinate maps to canvas X, Game's Z-coordinate maps to canvas Y (same as track.html)
        const rawX = (driver.world_x / d) + x_offset;
        const rawY = (driver.world_z / d) + z_offset;
        
        // Apply the same scaling and centering as used for the track
        const canvasX = (rawX - minX) * scale + centerOffsetX;
        const canvasY = (rawY - minY) * scale + centerOffsetY;
        
        // Get team color for this driver
        const teamColor = TEAM_COLORS[driver.team] || TEAM_COLORS['DEFAULT'];
        
        // Draw driver marker
        ctx.fillStyle = teamColor;
        ctx.beginPath();
        ctx.arc(canvasX, canvasY, DRIVER_DOT_RADIUS, 0, 2 * Math.PI);
        ctx.fill();
        
        // Draw white border around the dot
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(canvasX, canvasY, DRIVER_DOT_RADIUS, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Optionally add driver initials or car number
        const driverInitials = driverName.split(' ').map(part => part[0]).join('').toUpperCase();
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(driverInitials, canvasX, canvasY);
      }
    }

    function displayNoTrackData() {
      // Hide canvas, show placeholder
      canvas.style.display = 'none';
      const placeholder = document.getElementById('trackPlaceholder');
      placeholder.style.display = 'flex';
      
      placeholder.innerHTML = `
        <div class="track-icon">🏁</div>
        <div>Track Map Placeholder</div>
        <div style="font-size: 12px; margin-top: 8px; opacity: 0.7;">
          ${currentTrack ? `No track data available for ${currentTrack}` : 'Track visualization will appear here'}
        </div>
      `;
    }    function updateTrackTitle() {
      const titleElement = document.getElementById("trackTitle");
      const trackNameElement = document.getElementById("trackName");
      
      let titleText = "";
      let trackNameText = "";
      
      if (currentTrack) {
        const trackDisplayName = currentTrack.toUpperCase();
        const sessionDisplayName = currentSessionType !== null ? 
          SESSION_TYPES[currentSessionType] || 'Unknown Session' : '';
        
        if (sessionDisplayName) {
          titleText = `${trackDisplayName} - ${sessionDisplayName}`;
          trackNameText = `${trackDisplayName} - ${sessionDisplayName}`;
        } else {
          titleText = trackDisplayName;
          trackNameText = trackDisplayName;
        }
        
        titleElement.textContent = titleText;
        trackNameElement.textContent = trackNameText;
        document.title = `F1 ${titleText} Dashboard`;
      } else {
        titleElement.textContent = "DASHBOARD";
        trackNameElement.textContent = "Circuit Name";
        document.title = "F1 24 Dashboard";
      }
    }

    function getCurrentDriverInfo(driverId) {
      // Return stored driver info from latest telemetry
      return currentDriverInfo[driverId] || {
        driver_id: driverId,
        name: `Driver ${driverId}`,
        team_id: Math.floor(driverId / 2) + 1 // Fallback team assignment
      };
    }

    async function loadCurrentTrack() {
      try {
        const response = await fetch('/api/track');
        if (response.ok) {
          const data = await response.json();
          if (data.name) {
            currentTrack = data.name.toLowerCase();
            updateTrackTitle();
            loadTrackVisualization(currentTrack);
          }
        }
      } catch (error) {
        console.error('Error loading current track:', error);
      }
    }    async function loadTrackVisualization(trackName) {
      try {
        console.log(`Loading track visualization for: ${trackName}`);
        
        // First check if we have scaling parameters for this track
        const trackParams = TRACK_DICTIONARY[trackName.toLowerCase()];
        if (!trackParams) {
          console.warn(`No visualization parameters available for ${trackName}`);
          displayNoTrackData();
          return;
        }

        console.log(`Track parameters found:`, trackParams);

        // Load track data
        const response = await fetch(`/api/track/data?track=${encodeURIComponent(trackName)}`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const newTrackData = await response.json();
        console.log(`Track data loaded:`, newTrackData);
        
        if (!newTrackData.points || newTrackData.points.length === 0) {
          console.warn('No track points available');
          displayNoTrackData();
          return;
        }

        // Store track data and show canvas
        trackData = newTrackData;
        canvas.style.display = 'block';
        document.getElementById('trackPlaceholder').style.display = 'none';
        
        console.log(`About to draw track with ${newTrackData.points.length} points`);

        // Draw the track
        drawTrackOnCanvas(trackData, trackParams);
        
        console.log(`Track loaded: ${trackData.name} (${trackData.points.length} points)`);
        
      } catch (error) {
        console.error('Error loading track:', error);
        displayNoTrackData();
      }
    }

    function initializeWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws`;
      
      socket = new WebSocket(wsUrl);
      
      socket.onopen = () => {
        console.log('WebSocket connected');
      };
      
      socket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleWebSocketMessage(message);
        } catch (error) {
          console.error('Error parsing WebSocket message:', error);
        }
      };
      
      socket.onclose = () => {
        console.log('WebSocket disconnected, attempting to reconnect...');
        setTimeout(initializeWebSocket, 2000);
      };
      
      socket.onerror = (error) => {
        console.error('WebSocket error:', error);
        socket.close();
      };
    }

    function handleWebSocketMessage(message) {
      switch(message.type) {
        case "user_update":
          console.log("User update received:", message);
          break;
          
        case "laptime_update":
          console.log("Lap time update received:", message);
          // Refresh display data when lap times change
          loadDisplayData();
          break;
          
        case "track_update":
          console.log("Track update received:", message);
          // Update track name and refresh display data
          if (message.data && message.data.name) {
            currentTrack = message.data.name.toLowerCase();
            updateTrackTitle();
            loadTrackVisualization(currentTrack);
          }
          loadDisplayData();
          break;
          
        default:
          console.log("Unknown message type:", message.type);
      }
    }

    async function loadSessionData() {
      try {
        const response = await fetch("/api/telemetry/live_data_v2");
        if (response.ok) {
          const data = await response.json();
          if (data.sessionInfo && data.sessionInfo.sessionType !== null) {
            currentSessionType = data.sessionInfo.sessionType;
            updateTrackTitle();
          }
        }
      } catch (error) {
        console.error("Error loading session data:", error);
      }
    }
  </script>
</body>
</html>
